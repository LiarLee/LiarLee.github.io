   vmstat 提供的信息是从硬件和物理参数的角度。**vmstat 第一次的数据显示的是从上一次重启到现在的平均值，所以只能用来参考。**
   标题内容就不在解释了，分别是 **进程 ， 内存， 交换 ， IO， 系统 ， 和 CPU**。
   
   详细参数如下：
   r - 等待运行的进程数量,  多少个进程在R状态， 并一直取得并占用CPU时间片。 
   b - Uninterreptable Sleep的进程数量， 有多少个处于D状态显示的进程， 通常代表有多少个进程正常等待IO资源。 
   swpd： VirtualMemory的值 （KB）, 交换的使用量，如果未开启交换分区就会显示是 0。 这个指标和后面的 si so 是整体的， swpd 有用量， 那么si/so 就有数据， swpd 是 0， 那么永远不会有 si/so。
   free： IdleMemory的值（KB), 完全可用的内存，  这里free的内存是 完全没有被分配的。total - buffer - cache - used 计算完了之后剩下的, 与 free 命令中的 free 字段是同样的含义。
   buff： 被buffer使用的内存量（KB），被 buff 使用的内存空间。 
   cache： 被cache使用的内存量（KB）， 被 cache 占用的内存空间， 这部分和buffer 一样， 是临时数据，在落盘后buffer 会被释放， cache可以直接被释放。
   si： Swapin 内存从硬盘换入的数据量 （KB/s)， **读取交换分区（disk）到 内存** 的数据量 。
   so：Swapout 内存交换到硬盘的数据量 （KB/s）， **写入磁盘交换分区**的数据量。  
   bi： blockin， 发送到块设备的块数量（blocks/s),   系统收到disk发送来的数据量， 也就是通常说的**读磁盘数据。** 
   bo： blockout ， 从块设备接收的块数量（blocks/s）， 系统写入disk的数据量， 也就是通常说的**写磁盘数据**。
   in： 包括时钟在内的那**每秒中断数**。
   cs： **进程上下文每秒切换**的次数。
   us：非内核代码使用的CPU百分比， 包括**用户时间和Nice时间**。
   sy：**内核代码**使用的CPU时间百分比。
   id： CPU的**空闲时间**百分比。
   wa：**等待IO操作**花费的时间百分比。 这个容易误解的是， wa 其实cpu 是空闲的， 统计的方式是， 在收集数据的时候有多少个进程处于需要处理io或者等待处理io的状态， 当时那个时刻的百分比， 而实际上等待io的时间其实CPU没有做事， 所以在CPU的度量上， 这个时间的CPU是可以做其他事情的， 可以被其他需要进行计算的进程使用掉这部分时间。
   st：**虚拟化层**操作花费的时间百分比。这个通常是指虚拟化层的限制。 这个指标如果有， 那么表示虚拟化层对cpu的使用进行了限制（EC2 T系列实例） 或者是 底层的资源并不完全满足需求而导致的争抢。
   gu： Time spent running KVM guest code (guest time, including guest nice). ， 这个是新添加的指标， 之前没有见过。 如果是KVM host os 上面这个指标还是比较有用的。  

输出结果如下：
   ```bash
   hayden@HaydenArchRPi4 ~ vmstat -w 1
   --procs-- -----------------------memory---------------------- ---swap-- -----io---- -system-- ----------cpu----------
      r    b         swpd         free         buff        cache   si   so    bi    bo   in   cs  us  sy  id  wa  st  gu
      2    0      1005492        42600         1328      1973356    4    7    77   312 1767    6   2   2  95   1   0   0
      1    0      1005492        42652         1328      1973360    0    0     0     0 2519 3373   1   2  97   0   0   0
      1    0      1005492        42652         1328      1973360    0    0     0     8 1001 1844   0   1  99   0   0   0
      1    0      1005492        42652         1328      1973360    0    0     0    12 1056 1822   1   0  99   0   0   0
      1    0      1005492        42652         1328      1973368    0    0     0     0 1308 2150   1   1  98   0   0   0
      1    0      1005492        43156         1328      1973376    0    0     0     0 1394 2245   3   1  97   0   0   0
      1    0      1005492        43156         1328      1973376    0    0     0     0 1125 1898   1   1  99   0   0   0
      1    0      1005492        43408         1328      1973376    0    0     0    55 1229 2218   1   1  99   0   0   0
      1    0      1005492        44948         1328      1973392    0    0     0     0 3544 5490   7   4  89   0   0   0
      1    0      1005492        45228         1328      1973428    0    0     0     0 1410 2082   3   4  93   0   0   0
   ```
---
### 分析指标的逻辑
输出之后 先看前几次输出的 r 和 b。 
  r 有没有超过核心数；
  b 这里是不是有数据， 数据在运行命令的周期是不是一直存在， 数量有没有超过CPU核心数。变化的频率的幅度是什么样的。 
    例子： 
    总共观察10s ， 每秒输出一次数据， 每秒都有 超过cpu 核心数的 不可中断进程， 那么这就是代表当前的操作系统可能存在大量的密集io进程， 并且io负载较大。 

然后看最后一列的CPU情况， id的数据是多少，如果这个时候id 比较小， 看 us/sy/wa ，cpu 把时间花费在了什么地方。 
通常的场景下， cpu 应该把时间尽可能的使用在 us 这个部分。 如果其他而部分比较多的就需要关注较多的那个部分了。 

有交换就看看交换， 没有交换直接看内存相关， cache + free 总共有多少。如果内存用量是不是在oom 的边缘 ，然后再看 in/cs，  一个是硬中断次数， 一个是进程上下文切换次数， 这两个一个可能代表潜在的cpu被硬件事件终止， 另一个cpu忙于在进程之间反复横跳。 这些都可能指向当前系统的效率并不高， 或者潜在的问题。 

### 命令示例
   vmstat -m -- 显示内核占用内存的分配情况。
   vmstat -a -- 将内存的使用量分为**活动内存**和**非活动内存**。
   vmstat -n 2 10 -- 展示vmstat的结果10次， 每两秒一次。

### 更多参考
https://docs.oracle.com/cd/E19455-01/805-7229/6j6q8svh5/index.html